> 데이터 분석 툴 중 일부만 정리함</br>
> 간과한 부분 있으니 필요하면 채워넣을 예정임

# 2단원 데이터 분석 기본
## 2.1 넘파이 기본
```python
data1 = [1, 2, 3, 4]
array1 = np.array(data1) # 넘파이 배열 만들기
```

```python
array1.ndim # 차원 ex) 1
array1.shape # 크기 ex) (1,4)
array1.dtype # 데이터 타입 확인
```

```python
np.zeros(10) # 0으로 채워넣음
np.zeros((5,10)) # (행,열) 참고로 삼차원도 가능!
np.ones(10) # 1로 채워넣음
```

```python
np.arange(10) # 원소 10개짜리 배열 생성
np.arange(5,10,3) # (시작,끝,단계) 미리 지정한 배열 생성
```

```python
# 데이터 타입 변환
array1_float = array1.astype(np.float64)
array1_string = np.array(array1, dtype = np.string_)
```

```python
# 배열의 산술연산
array2 = np.array([1, 2, 3, 4, 5])
array3 = np.array([6, 7, 8, 9, 10])

array2 + array3
array2 - array3
array2 * array3
1/array2
array2**0.25
array2 > array3 # 불리언 연산은 불리언 배열로 반환!
```

```python
# 인덱싱과 슬라이싱
array4 = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
array4[7] # 인덱스 번호를 입력한 것! 그래서 7이 반환됨!
array4[[7, 9]] # 괄호 두 번 감싸줘야 한다! array([7, 9]) 

array4[4:7] # array([4, 5, 6])
array4[4:7] = 10 # 특정 값 대입 array([ 0,  1,  2,  3, 10, 10, 10,  7,  8,  9])

array5 = np.array([[1, 2, 3], [4, 5, 6]])
array5[1] # array([4, 5, 6])
array5[1, 2] # 6

array5[:2] # array([[1, 2, 3], [4, 5, 6]])
array5[:2, :2] # array([[1,2], [4,5]])
array5[[0, 1], :2] # array([[1, 2], [4, 5]])
array5[:, :1] # '인덱스' 전체 선택 array5([1], [4])
array5[:1, :] # '열' 전체 선택 array([[1, 2, 3]])
```

```python
# 통계 관련 함수
len(arr) # 길이

np.mean(arr) # 평균
arr.mean() # 이렇게 다른 함수들도 간단하게 쓸 수 있음! 옆에 괄호 쓰는 거 잊지 말기!

np.median(arr) # 중앙값

np.std(arr) # 표준 편차
np.var(arr) # 표본 분산

arr.min() # 최솟값
arr.max() # 최댓값

arr.sum() # 합
arr.cumsum() # 누적합
arr.cumprod() # 누적곱

np.percentile(arr, 0) # 사분위수 구하기 0, 25, 50, 75, 100 입력 가능함

arr1 = np.array([5, 7, 2, 3, 1, 4, 6])
arr1.sort()
arr1 # array([1, 2, 3, 4, 5, 6, 7])

# 집합 관련 함수
fruits = np.array(['apple', 'banana', 'kiwi','grape', 'kiwi', 'apple'])
np.unique(fruits) # 데이터 겹치는 것 없이 반환 array(['apple', 'banana', 'grape', 'kiwi'], dtype='<U6')

sorted(set(fruits)) # 리스트로 반환 ['apple', 'banana', 'grape', 'kiwi']

np.intersect1d(x, y) # 교집합
np.union1d(x, y) # 합집합
np.in1d(x, y) # x가 y에 포함? 불리언 배열 반환
np.setdiff1d(x, y) # 차집합 중 XOR인 것 반환
```

